var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Learn2018Helper_provider, _Learn2018Helper_rawFetch, _Learn2018Helper_myFetch, _Learn2018Helper_myFetchWithToken, _Learn2018Helper_csrfToken, _Learn2018Helper_withReAuth;
import * as cheerio from 'cheerio';
import { Base64 } from 'js-base64';
import fetch from 'cross-fetch';
import * as URL from './urls.js';
import { ContentType, FailReason, CourseType, } from './types.js';
import { decodeHTML, mapGradeToLevel, parseSemesterType, trimAndDefine, JSONP_EXTRACTOR_NAME, extractJSONPResult, } from './utils.js';
// .d.ts files are in types/
import IsomorphicFetch from 'real-isomorphic-fetch';
import tough from 'tough-cookie-no-native';
const CHEERIO_CONFIG = {
    _useHtmlParser2: true,
    decodeEntities: false,
};
const $ = (html) => {
    /* eslint-disable */
    // `cheerio.load` has two prototypes:
    // 1. `(html: string | Buffer, options?: CheerioParserOptions | undefined): Root`
    // 2. `(element: Element | Element[], options?: CheerioParserOptions | undefined): Root`
    // TypeScript cannot handle this, so we must workaround this.
    // @ts-ignore: No overload matches this call
    return cheerio.load(html, CHEERIO_CONFIG);
    /* eslint-enable */
};
const noLogin = (res) => res.url.includes('login_timeout') || res.status == 403;
/** add CSRF token to any request URL as parameters */
export const addCSRFTokenToUrl = (url, token) => {
    if (url.includes('?')) {
        url += `&_csrf=${token}`;
    }
    else {
        url += `?_csrf=${token}`;
    }
    return url;
};
/** the main helper class */
export class Learn2018Helper {
    /** you can provide a CookieJar and / or CredentialProvider in the configuration */
    constructor(config) {
        var _a, _b;
        _Learn2018Helper_provider.set(this, void 0);
        _Learn2018Helper_rawFetch.set(this, void 0);
        _Learn2018Helper_myFetch.set(this, void 0);
        _Learn2018Helper_myFetchWithToken.set(this, async (...args) => {
            if (__classPrivateFieldGet(this, _Learn2018Helper_csrfToken, "f") == '') {
                await this.login();
            }
            const [url, ...remaining] = args;
            return __classPrivateFieldGet(this, _Learn2018Helper_myFetch, "f").call(this, addCSRFTokenToUrl(url, __classPrivateFieldGet(this, _Learn2018Helper_csrfToken, "f")), ...remaining);
        });
        _Learn2018Helper_csrfToken.set(this, '');
        _Learn2018Helper_withReAuth.set(this, (rawFetch) => {
            const login = this.login.bind(this);
            return async function wrappedFetch(...args) {
                const retryAfterLogin = async () => {
                    await login();
                    return await rawFetch(...args).then((res) => {
                        if (noLogin(res)) {
                            return Promise.reject({
                                reason: FailReason.NOT_LOGGED_IN,
                            });
                        }
                        else if (res.status != 200) {
                            return Promise.reject({
                                reason: FailReason.UNEXPECTED_STATUS,
                                extra: {
                                    code: res.status,
                                    text: res.statusText,
                                },
                            });
                        }
                        else {
                            return res;
                        }
                    });
                };
                return await rawFetch(...args).then((res) => (noLogin(res) ? retryAfterLogin() : res));
            };
        });
        this.previewFirstPage = (_a = config === null || config === void 0 ? void 0 : config.generatePreviewUrlForFirstPage) !== null && _a !== void 0 ? _a : true;
        this.cookieJar = (_b = config === null || config === void 0 ? void 0 : config.cookieJar) !== null && _b !== void 0 ? _b : new tough.CookieJar();
        __classPrivateFieldSet(this, _Learn2018Helper_provider, config === null || config === void 0 ? void 0 : config.provider, "f");
        __classPrivateFieldSet(this, _Learn2018Helper_rawFetch, new IsomorphicFetch(fetch, this.cookieJar), "f");
        __classPrivateFieldSet(this, _Learn2018Helper_myFetch, __classPrivateFieldGet(this, _Learn2018Helper_provider, "f")
            ? __classPrivateFieldGet(this, _Learn2018Helper_withReAuth, "f").call(this, __classPrivateFieldGet(this, _Learn2018Helper_rawFetch, "f"))
            : async (...args) => {
                const result = await __classPrivateFieldGet(this, _Learn2018Helper_rawFetch, "f").call(this, ...args);
                if (noLogin(result))
                    return Promise.reject({
                        reason: FailReason.NOT_LOGGED_IN,
                    });
                return result;
            }, "f");
    }
    /** fetch CSRF token from helper (invalid after login / re-login), might be '' if not logged in */
    getCSRFToken() {
        return __classPrivateFieldGet(this, _Learn2018Helper_csrfToken, "f");
    }
    /** login is necessary if you do not provide a `CredentialProvider` */
    async login(username, password) {
        if (!username || !password) {
            if (!__classPrivateFieldGet(this, _Learn2018Helper_provider, "f"))
                return Promise.reject({
                    reason: FailReason.NO_CREDENTIAL,
                });
            const credential = await __classPrivateFieldGet(this, _Learn2018Helper_provider, "f").call(this);
            username = credential.username;
            password = credential.password;
        }
        const ticketResponse = await __classPrivateFieldGet(this, _Learn2018Helper_rawFetch, "f").call(this, URL.ID_LOGIN(), {
            body: URL.ID_LOGIN_FORM_DATA(username, password),
            method: 'POST',
        });
        if (!ticketResponse.ok) {
            return Promise.reject({
                reason: FailReason.ERROR_FETCH_FROM_ID,
            });
        }
        // check response from id.tsinghua.edu.cn
        const ticketResult = await ticketResponse.text();
        const body = $(ticketResult);
        const targetURL = body('a').attr('href');
        const ticket = targetURL.split('=').slice(-1)[0];
        if (ticket === 'BAD_CREDENTIALS') {
            return Promise.reject({
                reason: FailReason.BAD_CREDENTIAL,
            });
        }
        const loginResponse = await __classPrivateFieldGet(this, _Learn2018Helper_rawFetch, "f").call(this, URL.LEARN_AUTH_ROAM(ticket));
        if (loginResponse.ok !== true) {
            return Promise.reject({
                reason: FailReason.ERROR_ROAMING,
            });
        }
        const courseListPageSource = await (await __classPrivateFieldGet(this, _Learn2018Helper_rawFetch, "f").call(this, URL.LEARN_STUDENT_COURSE_LIST_PAGE())).text();
        const tokenRegex = /^.*&_csrf=(\S*)".*$/gm;
        const matches = [...courseListPageSource.matchAll(tokenRegex)];
        if (matches.length == 0) {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: 'cannot fetch CSRF token from source',
            });
        }
        __classPrivateFieldSet(this, _Learn2018Helper_csrfToken, matches[0][1], "f");
    }
    /**  logout (to make everyone happy) */
    async logout() {
        await __classPrivateFieldGet(this, _Learn2018Helper_rawFetch, "f").call(this, URL.LEARN_LOGOUT(), { method: 'POST' });
    }
    /**
     * Get calendar items during the specified period (in yyyymmdd format).
     * @param startDate start date (inclusive)
     * @param endDate end date (inclusive)
     * If the API returns any error, this function will throw `FailReason.INVALID_RESPONSE`,
     * and we currently observe a limit of no more that 29 days.
     * Otherwise it will return the parsed data (might be empty if the period is too far away from now)
     */
    async getCalendar(startDate, endDate, graduate = false) {
        const ticketResponse = await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.REGISTRAR_TICKET(), {
            method: 'POST',
            body: URL.REGISTRAR_TICKET_FORM_DATA(),
        });
        let ticket = (await ticketResponse.text());
        ticket = ticket.substring(1, ticket.length - 1);
        await __classPrivateFieldGet(this, _Learn2018Helper_myFetch, "f").call(this, URL.REGISTRAR_AUTH(ticket));
        const response = await __classPrivateFieldGet(this, _Learn2018Helper_myFetch, "f").call(this, URL.REGISTRAR_CALENDAR(startDate, endDate, graduate, JSONP_EXTRACTOR_NAME));
        if (!response.ok) {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
            });
        }
        const result = extractJSONPResult(await response.text());
        return result.map((i) => ({
            location: i.dd,
            status: i.fl,
            startTime: i.kssj,
            endTime: i.jssj,
            date: i.nq,
            courseName: i.nr,
        }));
    }
    async getSemesterIdList() {
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_SEMESTER_LIST())).json();
        if (!Array.isArray(json)) {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const semesters = json;
        // sometimes web learning returns null, so confusing...
        return semesters.filter((s) => s != null);
    }
    async getCurrentSemester() {
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_CURRENT_SEMESTER())).json();
        if (json.message !== 'success') {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const result = json.result;
        return {
            id: result.id,
            startDate: new Date(result.kssj),
            endDate: new Date(result.jssj),
            startYear: Number(result.xnxq.slice(0, 4)),
            endYear: Number(result.xnxq.slice(5, 9)),
            type: parseSemesterType(Number(result.xnxq.slice(10, 11))),
        };
    }
    /** get all courses in the specified semester */
    async getCourseList(semesterID, courseType = CourseType.STUDENT) {
        var _a;
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_COURSE_LIST(semesterID, courseType))).json();
        if (json.message !== 'success' || !Array.isArray(json.resultList)) {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const result = ((_a = json.resultList) !== null && _a !== void 0 ? _a : []);
        const courses = [];
        await Promise.all(result.map(async (c) => {
            var _a;
            courses.push({
                id: c.wlkcid,
                name: c.kcm,
                englishName: c.ywkcm,
                timeAndLocation: await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_COURSE_TIME_LOCATION(c.wlkcid))).json(),
                url: URL.LEARN_COURSE_URL(c.wlkcid, courseType),
                teacherName: (_a = c.jsm) !== null && _a !== void 0 ? _a : '',
                teacherNumber: c.jsh,
                courseNumber: c.kch,
                courseIndex: Number(c.kxh),
                courseType,
            });
        }));
        return courses;
    }
    /**
     * Get certain type of content of all specified courses.
     * It actually wraps around other `getXXX` functions. You can ignore the failure caused by certain courses.
     */
    async getAllContents(courseIDs, type, courseType = CourseType.STUDENT, allowFailure = false) {
        let fetchFunc;
        switch (type) {
            case ContentType.NOTIFICATION:
                fetchFunc = this.getNotificationList;
                break;
            case ContentType.FILE:
                fetchFunc = this.getFileList;
                break;
            case ContentType.HOMEWORK:
                fetchFunc = this.getHomeworkList;
                break;
            case ContentType.DISCUSSION:
                fetchFunc = this.getDiscussionList;
                break;
            case ContentType.QUESTION:
                fetchFunc = this.getAnsweredQuestionList;
                break;
        }
        const contents = {};
        const results = await Promise.allSettled(courseIDs.map(async (id) => {
            contents[id] = await fetchFunc.bind(this)(id, courseType);
        }));
        if (!allowFailure) {
            for (const r of results) {
                if (r.status == 'rejected') {
                    return Promise.reject({
                        reason: FailReason.INVALID_RESPONSE,
                        extra: {
                            reason: r.reason,
                        },
                    });
                }
            }
        }
        return contents;
    }
    /** Get all notifications （课程公告） of the specified course. */
    async getNotificationList(courseID, courseType = CourseType.STUDENT) {
        var _a, _b, _c, _d;
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_NOTIFICATION_LIST(courseID, courseType))).json();
        if (json.result !== 'success') {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const result = ((_d = (_b = (_a = json.object) === null || _a === void 0 ? void 0 : _a.aaData) !== null && _b !== void 0 ? _b : (_c = json.object) === null || _c === void 0 ? void 0 : _c.resultsList) !== null && _d !== void 0 ? _d : []);
        const notifications = [];
        await Promise.all(result.map(async (n) => {
            var _a;
            const notification = {
                id: n.ggid,
                content: decodeHTML(Base64.decode((_a = n.ggnr) !== null && _a !== void 0 ? _a : '')),
                title: decodeHTML(n.bt),
                url: URL.LEARN_NOTIFICATION_DETAIL(courseID, n.ggid, courseType),
                publisher: n.fbrxm,
                hasRead: n.sfyd === '是',
                markedImportant: Number(n.sfqd) === 1,
                publishTime: new Date(n.fbsj && typeof n.fbsj === 'string' ? n.fbsj : n.fbsjStr),
            };
            let detail = {};
            const attachmentName = courseType === CourseType.STUDENT ? n.fjmc : n.fjbt;
            if (attachmentName) {
                detail = await this.parseNotificationDetail(courseID, notification.id, courseType, attachmentName);
            }
            notifications.push({ ...notification, ...detail });
        }));
        return notifications;
    }
    /** Get all files （课程文件） of the specified course. */
    async getFileList(courseID, courseType = CourseType.STUDENT) {
        var _a;
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_FILE_LIST(courseID, courseType))).json();
        if (json.result !== 'success') {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        let result = [];
        if (Array.isArray((_a = json.object) === null || _a === void 0 ? void 0 : _a.resultsList)) {
            // teacher
            result = json.object.resultsList;
        }
        else if (Array.isArray(json.object)) {
            // student
            result = json.object;
        }
        const files = [];
        await Promise.all(result.map(async (f) => {
            var _a, _b;
            const title = decodeHTML(f.bt);
            const downloadUrl = URL.LEARN_FILE_DOWNLOAD(courseType === CourseType.STUDENT ? f.wjid : f.id, courseType, courseID);
            const previewUrl = URL.LEARN_FILE_PREVIEW(ContentType.FILE, f.wjid, courseType, this.previewFirstPage);
            files.push({
                id: f.wjid,
                title: decodeHTML(f.bt),
                description: decodeHTML(f.ms),
                rawSize: f.wjdx,
                size: f.fileSize,
                uploadTime: new Date(f.scsj),
                downloadUrl,
                previewUrl,
                isNew: f.isNew,
                markedImportant: f.sfqd === 1,
                visitCount: (_a = f.llcs) !== null && _a !== void 0 ? _a : 0,
                downloadCount: (_b = f.xzcs) !== null && _b !== void 0 ? _b : 0,
                fileType: f.wjlx,
                remoteFile: {
                    id: f.wjid,
                    name: title,
                    downloadUrl,
                    previewUrl,
                    size: f.fileSize,
                },
            });
        }));
        return files;
    }
    /** Get all homeworks （课程作业） of the specified course (support student version only). */
    async getHomeworkList(courseID, courseType = CourseType.STUDENT) {
        if (courseType === CourseType.TEACHER) {
            return Promise.reject({
                reason: FailReason.NOT_IMPLEMENTED,
                extra: 'currently getting homework list of TA courses is not supported',
            });
        }
        const allHomework = [];
        await Promise.all(URL.LEARN_HOMEWORK_LIST_SOURCE(courseID).map(async (s) => {
            const homeworks = await this.getHomeworkListAtUrl(s.url, s.status);
            allHomework.push(...homeworks);
        }));
        return allHomework;
    }
    /** Get all discussions （课程讨论） of the specified course. */
    async getDiscussionList(courseID, courseType = CourseType.STUDENT) {
        var _a, _b;
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_DISCUSSION_LIST(courseID, courseType))).json();
        if (json.result !== 'success') {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const result = ((_b = (_a = json.object) === null || _a === void 0 ? void 0 : _a.resultsList) !== null && _b !== void 0 ? _b : []);
        const discussions = [];
        await Promise.all(result.map(async (d) => {
            discussions.push({
                ...this.parseDiscussionBase(d),
                boardId: d.bqid,
                url: URL.LEARN_DISCUSSION_DETAIL(d.wlkcid, d.bqid, d.id, courseType),
            });
        }));
        return discussions;
    }
    /**
     * Get all notifications （课程答疑） of the specified course.
     * The student version supports only answered questions, while the teacher version supports all questions.
     */
    async getAnsweredQuestionList(courseID, courseType = CourseType.STUDENT) {
        var _a, _b;
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_QUESTION_LIST_ANSWERED(courseID, courseType))).json();
        if (json.result !== 'success') {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const result = ((_b = (_a = json.object) === null || _a === void 0 ? void 0 : _a.resultsList) !== null && _b !== void 0 ? _b : []);
        const questions = [];
        await Promise.all(result.map(async (q) => {
            questions.push({
                ...this.parseDiscussionBase(q),
                question: Base64.decode(q.wtnr),
                url: URL.LEARN_QUESTION_DETAIL(q.wlkcid, q.id, courseType),
            });
        }));
        return questions;
    }
    async getHomeworkListAtUrl(url, status) {
        var _a, _b;
        const json = await (await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, url)).json();
        if (json.result !== 'success') {
            return Promise.reject({
                reason: FailReason.INVALID_RESPONSE,
                extra: json,
            });
        }
        const result = ((_b = (_a = json.object) === null || _a === void 0 ? void 0 : _a.aaData) !== null && _b !== void 0 ? _b : []);
        const homeworks = [];
        await Promise.all(result.map(async (h) => {
            homeworks.push({
                id: h.zyid,
                studentHomeworkId: h.xszyid,
                title: decodeHTML(h.bt),
                url: URL.LEARN_HOMEWORK_DETAIL(h.wlkcid, h.zyid, h.xszyid),
                deadline: new Date(h.jzsj),
                submitUrl: URL.LEARN_HOMEWORK_SUBMIT(h.wlkcid, h.xszyid),
                submitTime: h.scsj === null ? undefined : new Date(h.scsj),
                grade: h.cj === null ? undefined : h.cj,
                gradeLevel: mapGradeToLevel(h.cj),
                graderName: trimAndDefine(h.jsm),
                gradeContent: trimAndDefine(h.pynr),
                gradeTime: h.pysj === null ? undefined : new Date(h.pysj),
                ...status,
                ...(await this.parseHomeworkDetail(h.wlkcid, h.zyid, h.xszyid)),
            });
        }));
        return homeworks;
    }
    async parseNotificationDetail(courseID, id, courseType, attachmentName) {
        /// from JSON (backup, currently not used)
        // const postParams = new FormData();
        // postParams.append('id', id);
        // postParams.append('wlkcid', courseID);
        // const metadata = await (await this.#myFetchWithToken(URL.LEARN_NOTIFICATION_EDIT(courseType), {
        //   'method': 'POST',
        //   'body': postParams,
        // })).json();
        // const attachmentId = metadata.ggfjid as string;
        /// parsed from HTML
        const response = await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_NOTIFICATION_DETAIL(courseID, id, courseType));
        const result = $(await response.text());
        let path = '';
        if (courseType === CourseType.STUDENT) {
            path = result('.ml-10').attr('href');
        }
        else {
            path = result('#wjid').attr('href');
        }
        const size = trimAndDefine(result('div#attachment > div.fl > span[class^="color"]').first().text());
        const params = new URLSearchParams(path.split('?').slice(-1)[0]);
        const attachmentId = params.get('wjid');
        if (!path.startsWith(URL.LEARN_PREFIX)) {
            path = URL.LEARN_PREFIX + path;
        }
        return {
            attachment: {
                name: attachmentName,
                id: attachmentId,
                downloadUrl: path,
                previewUrl: URL.LEARN_FILE_PREVIEW(ContentType.NOTIFICATION, attachmentId, courseType, this.previewFirstPage),
                size,
            },
        };
    }
    async parseHomeworkDetail(courseID, id, studentHomeworkID) {
        const response = await __classPrivateFieldGet(this, _Learn2018Helper_myFetchWithToken, "f").call(this, URL.LEARN_HOMEWORK_DETAIL(courseID, id, studentHomeworkID));
        const result = $(await response.text());
        const fileDivs = result('div.list.fujian.clearfix');
        return {
            description: trimAndDefine(result('div.list.calendar.clearfix > div.fl.right > div.c55').slice(0, 1).html()),
            answerContent: trimAndDefine(result('div.list.calendar.clearfix > div.fl.right > div.c55').slice(1, 2).html()),
            submittedContent: trimAndDefine($(result('div.boxbox').slice(1, 2).toArray())('div.right').slice(2, 3).html()),
            attachment: this.parseHomeworkFile(fileDivs[0]),
            answerAttachment: this.parseHomeworkFile(fileDivs[1]),
            submittedAttachment: this.parseHomeworkFile(fileDivs[2]),
            gradeAttachment: this.parseHomeworkFile(fileDivs[3]),
        };
    }
    parseHomeworkFile(fileDiv) {
        var _a;
        const fileNode = ((_a = $(fileDiv)('.ftitle').children('a')[0]) !== null && _a !== void 0 ? _a : $(fileDiv)('.fl').children('a')[0]);
        if (fileNode !== undefined) {
            const size = trimAndDefine($(fileDiv)('.fl > span[class^="color"]').first().text());
            const params = new URLSearchParams(fileNode.attribs.href.split('?').slice(-1)[0]);
            const attachmentId = params.get('fileId');
            // so dirty here...
            let downloadUrl = URL.LEARN_PREFIX + fileNode.attribs.href;
            if (params.has('downloadUrl')) {
                downloadUrl = URL.LEARN_PREFIX + params.get('downloadUrl');
            }
            return {
                id: attachmentId,
                name: fileNode.children[0].data,
                downloadUrl,
                previewUrl: URL.LEARN_FILE_PREVIEW(ContentType.HOMEWORK, attachmentId, CourseType.STUDENT, this.previewFirstPage),
                size,
            };
        }
        else {
            return undefined;
        }
    }
    parseDiscussionBase(d) {
        var _a;
        return {
            id: d.id,
            title: decodeHTML(d.bt),
            publisherName: d.fbrxm,
            publishTime: new Date(d.fbsj),
            lastReplyTime: new Date(d.zhhfsj),
            lastReplierName: d.zhhfrxm,
            visitCount: (_a = d.djs) !== null && _a !== void 0 ? _a : 0,
            replyCount: d.hfcs,
        };
    }
}
_Learn2018Helper_provider = new WeakMap(), _Learn2018Helper_rawFetch = new WeakMap(), _Learn2018Helper_myFetch = new WeakMap(), _Learn2018Helper_myFetchWithToken = new WeakMap(), _Learn2018Helper_csrfToken = new WeakMap(), _Learn2018Helper_withReAuth = new WeakMap();
