"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPersons = exports.Form = exports.Person = exports.Overall = exports.InputTag = void 0;
const error_1 = require("../../utils/error");
const flatMap = (arr, transform) => arr.reduce((prev, curr, id) => prev.concat(transform(curr, id)), []);
/**
 * The minimal component of a form to be posted to the school server.
 *
 * Nobody knows what `name` stands for, but it is certain that `value`
 * stands for the score of a question in some occasions.
 */
class InputTag {
    constructor(input, value) {
        this.toPair = () => [this.name, this.value];
        this.outOfRange = () => {
            const val = parseInt(this.value, 10);
            return val < 1 || val > 7;
        };
        const inputTag = input;
        if (typeof input === "string") {
            this.name = input;
            this.value = value || "";
        }
        else {
            this.name = inputTag.attribs.name;
            this.value = inputTag.attribs.value || "";
        }
    }
}
exports.InputTag = InputTag;
class Overall {
    constructor(suggestionTag, score) {
        this.suggestionTag = suggestionTag;
        this.score = score;
    }
    get suggestion() {
        return this.suggestionTag.value;
    }
    set suggestion(text) {
        this.suggestionTag.value = text;
    }
    toPairs() {
        return [this.suggestionTag.toPair(), this.score.toPair()];
    }
}
exports.Overall = Overall;
class Person {
    constructor(name, inputGroups) {
        this.name = name;
        this.inputGroups = inputGroups;
        this.outOfRange = () => this.inputGroups.some((inputGroup) => inputGroup.score.outOfRange());
    }
    autoScore(score = 7) {
        this.inputGroups.forEach((inputGroup) => (inputGroup.score.value = score.toString()));
    }
    get suggestion() {
        return this.inputGroups[0].suggestion.value;
    }
    set suggestion(text) {
        this.inputGroups.forEach((inputGroup) => {
            inputGroup.suggestion.value = text;
        });
    }
    toPairs() {
        return flatMap(this.inputGroups, (item) => item.others
            .concat(item.suggestion)
            .concat(item.score)
            .map((inputTag) => inputTag.toPair()));
    }
}
exports.Person = Person;
class Form {
    constructor(basics, overall, teachers, assistants) {
        this.basics = basics;
        this.overall = overall;
        this.teachers = teachers;
        this.assistants = assistants;
        /**
         * Check whether this form is valid to post.
         *
         * Returns a reason as a `string` if invalid, or `undefined` if else.
         */
        this.invalid = () => {
            try {
                if (this.overall.score.outOfRange()) {
                    return "overallOutOfRange";
                }
                else if (this.teachers.some((person) => person.outOfRange())) {
                    return "teachersOutOfRange";
                }
                else if (this.assistants.length > 0 &&
                    this.assistants.every((person) => person.outOfRange())) {
                    return "assistantsOutOfRange";
                }
                else {
                    return undefined;
                }
            }
            catch (e) {
                console.error(e);
                return "exceptionOccurred";
            }
        };
        /**
         * The form has to be serialized in order to be posted.
         */
        this.serialize = () => {
            const obj = Object.create(null);
            this.basics
                .map((inputTag) => inputTag.toPair())
                .forEach(([key, value]) => (obj[key] = value));
            this.overall.toPairs().forEach(([key, value]) => (obj[key] = value));
            flatMap(this.teachers, (person) => person.toPairs())
                .forEach(([key, value]) => (obj[key] = value));
            flatMap(this.assistants, (person) => person.toPairs())
                .forEach(([key, value]) => (obj[key] = value));
            return obj;
        };
    }
}
exports.Form = Form;
const assert = (exp) => {
    if (!exp) {
        throw new error_1.AssessmentError("Assertion failed!");
    }
};
/**
 * Read persons data from their corresponding html tables.
 */
const toPersons = (tables) => {
    const persons = [];
    let table = tables.children("table").first();
    while (table.children().length > 0) {
        let tr = table.children("tbody").children().first();
        const name = tr.children().first().text();
        let children;
        const inputGroups = [];
        while ((children = tr.children()).length > 0) {
            const question = children.length === 4
                ? children.first().next().text().trim()
                : children.first().text().trim();
            let inputs = children.find("input");
            const suggestions = inputs.filter("[class]");
            assert(suggestions.length === 1);
            const suggestion = new InputTag(suggestions[0]);
            inputs = inputs.filter(":not([class])");
            const scores = inputs.filter("ul > input");
            assert(scores.length === 1);
            const score = new InputTag(scores[0]);
            inputs = inputs.filter(":not([avgfs])");
            const others = inputs.map((_, ele) => new InputTag(ele)).get();
            const inputGroup = {
                question,
                suggestion,
                score,
                others,
            };
            inputGroups.push(inputGroup);
            tr = tr.next();
        }
        persons.push(new Person(name, inputGroups));
        table = table.next();
    }
    return persons;
};
exports.toPersons = toPersons;
//# sourceMappingURL=assessment.js.map