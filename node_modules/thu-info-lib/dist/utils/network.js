"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRedirectUrl = exports.uFetch = exports.stringify = exports.arbitraryEncode = exports.clearCookies = exports.cookies = void 0;
const strings_1 = require("../constants/strings");
const iconv_lite_1 = __importDefault(require("iconv-lite"));
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const abort_controller_1 = __importDefault(require("abort-controller"));
const error_1 = require("./error");
exports.cookies = {};
/**
 * Clear the cookies.
 */
const clearCookies = () => {
    Object.keys(exports.cookies).forEach((key) => delete exports.cookies[key]);
};
exports.clearCookies = clearCookies;
/**
 * An enhanced implementation of `encodeURIComponent`, which supports
 * arbitrary charset.
 */
const arbitraryEncode = (s, encoding = "UTF-8") => encoding === "UTF-8" ? encodeURIComponent(s) : String(s)
    .split("")
    .map((ch) => RegExp(/^[\u4e00-\u9fa5]*$/).test(ch)
    ? iconv_lite_1.default.encode(ch, encoding).reduce((a, b) => a + "%" + b.toString(16), "")
    : ch)
    .join("");
exports.arbitraryEncode = arbitraryEncode;
/**
 * Converts form data into url-encoded format (utf-8).
 */
const stringify = (form, paramEncoding = "UTF-8") => Object.keys(form)
    .map((key) => `${(0, exports.arbitraryEncode)(key, paramEncoding)}=${(0, exports.arbitraryEncode)(form[key], paramEncoding)}`)
    .join("&");
exports.stringify = stringify;
/**
 * Gets the response data from the given `url`.
 *
 * If param `post` is provided, a `POST` request with the given post form will
 * be sent. Otherwise, a `GET` request will be sent.
 *
 * The `timeout` is `60000` by default, in milliseconds.
 *
 * The `paramEncoding` is `UTF-8` by default, used to encode post form params.
 *
 * If `serialized` is `true`, the method will treat `post` as a string that has
 * already been serialized.
 */
const uFetch = async (url, post, timeout = 60000, paramEncoding = "UTF-8", serialized = false, requestContentType = strings_1.CONTENT_TYPE_FORM) => {
    // Prepare request headers
    const defaultHeaders = {
        // Setup content-type and user-agent
        "Content-Type": requestContentType,
        "User-Agent": strings_1.USER_AGENT,
    };
    const headers = global.FileReader === undefined ? {
        ...defaultHeaders,
        // Cookie should be manually set in Node.js
        Cookie: Object.keys(exports.cookies).map((key) => `${key}=${exports.cookies[key]}`).join(";"),
    } : defaultHeaders;
    // Handle timeout abortion
    const controller = new abort_controller_1.default();
    const timeoutEvent = setTimeout(() => {
        controller.abort();
    }, timeout);
    const defaultInit = {
        headers: headers,
        signal: controller.signal,
    };
    // Switch method to `POST` if post-body is provided
    const init = post === undefined
        ? defaultInit
        : {
            ...defaultInit,
            method: "POST",
            body: serialized ? post : (0, exports.stringify)(post, paramEncoding),
        };
    // Perform the network request
    try {
        const response = await (0, cross_fetch_1.default)(url, init);
        if (response.status !== 200 && response.status !== 201) {
            throw new error_1.ResponseStatusError(`Unexpected response status code: ${response.status}`);
        }
        // Manage cookies
        response.headers.forEach((value, key) => {
            if (key === "set-cookie") {
                const segment = value.split(";")[0];
                const [item, val] = segment.split("=");
                exports.cookies[item] = val;
            }
        });
        // Detect charset based on content-type
        const contentType = response.headers.get("Content-Type");
        let base64 = false;
        let charset = "UTF-8";
        if (contentType) {
            if (contentType.includes("application/octet-stream")) {
                base64 = true;
            }
            else {
                /charset=(.*?);/.test(contentType + ";");
                if (RegExp.$1)
                    charset = RegExp.$1;
            }
        }
        if (global.FileReader) {
            // For browser and react-native
            const blob = await response.blob();
            return await new Promise(((resolve, reject) => {
                // Use FileReader to read blob data
                const reader = new FileReader();
                reader.onloadend = () => {
                    if (typeof reader.result === "string") {
                        if (base64) {
                            // Simply return the string data with the MIME header removed
                            resolve(reader.result.substr("data:application/octet-stream;base64,".length));
                        }
                        else {
                            // The value stored in `reader.result` has already been parsed with the correct encoding
                            resolve(reader.result);
                        }
                    }
                    else {
                        // This should not happen
                        reject(new Error("Blob parsing error."));
                    }
                };
                // Read and transform
                if (base64) {
                    reader.readAsDataURL(blob);
                }
                else {
                    reader.readAsText(blob, charset);
                }
            }));
        }
        else {
            // For node.js
            const arrayBuffer = await response.arrayBuffer();
            // Use iconv-lite to transform arrayBuffer into string
            return iconv_lite_1.default.decode(Buffer.from(arrayBuffer), charset);
        }
    }
    finally {
        // We have to clear the timeout
        clearTimeout(timeoutEvent);
    }
};
exports.uFetch = uFetch;
const getRedirectUrl = async (url, timeout = 60000) => {
    if (global.FileReader) {
        // For browser and react-native
        return new Promise((resolve) => {
            const req = new XMLHttpRequest();
            req.onreadystatechange = () => {
                var _a;
                if (req.readyState === req.DONE) {
                    resolve((_a = req.responseURL) !== null && _a !== void 0 ? _a : "");
                }
            };
            req.open("GET", url);
            req.send();
        });
    }
    // Prepare request headers
    const defaultHeaders = {
        // Setup content-type and user-agent
        "Content-Type": strings_1.CONTENT_TYPE_FORM,
        "User-Agent": strings_1.USER_AGENT,
    };
    const headers = global.FileReader === undefined ? {
        ...defaultHeaders,
        // Cookie should be manually set in Node.js
        Cookie: Object.keys(exports.cookies).map((key) => `${key}=${exports.cookies[key]}`).join(";"),
    } : defaultHeaders;
    // Handle timeout abortion
    const controller = new abort_controller_1.default();
    const timeoutEvent = setTimeout(() => {
        controller.abort();
    }, timeout);
    const init = {
        headers: headers,
        signal: controller.signal,
        redirect: "manual" // Set the redirect mode to "manual" so fetch won't follow the http redirection
    };
    // Perform the network request
    try {
        const response = await (0, cross_fetch_1.default)(url, init);
        if (response.status !== 301 && response.status !== 302) {
            throw new error_1.ResponseStatusError(`Unexpected response status code: ${response.status}`);
        }
        // Get the redirection target url in header "Location" and return it
        const location = response.headers.get("Location");
        return location !== null && location !== void 0 ? location : "";
    }
    finally {
        // We have to clear the timeout
        clearTimeout(timeoutEvent);
    }
};
exports.getRedirectUrl = getRedirectUrl;
//# sourceMappingURL=network.js.map